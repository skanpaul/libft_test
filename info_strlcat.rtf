{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Bold;}
{\colortbl;\red255\green255\blue255;\red128\green0\blue128;\red0\green0\blue0;\red251\green2\blue7;
}
{\*\expandedcolortbl;;\cssrgb\c57919\c12801\c57269;\cssrgb\c0\c0\c0;\cssrgb\c100000\c14913\c0;
}
\margl1440\margr1440\vieww27260\viewh22720\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 NAME\
     strlcpy, strlcat -- size-bounded string copying and concatenation\
\
LIBRARY\
     Standard C Library (libc, -lc)\
\
SYNOPSIS\
     #include <string.h>\
\
     size_t\
     
\fs72 \cf2 strlcat
\fs24 \cf0 (char * restrict dst, const char * restrict src, size_t dstsize);\
\

\f1\b DESCRIPTION
\f0\b0 \
\
The strlcpy() and strlcat() functions copy and concatenate strings with the same input parameters and output result as snprintf(3).\
\
They are designed to be safer, more consistent, and less error prone replacements for the easily misused functions strncpy(3) and strncat(3).\
\
strlcpy() and 
\fs72 \cf2 1
\fs24 \cf3 strlcat() take the full size of the destination buffer and guarantee NUL-termination if there is room.  \cf0 \
\

\fs72 \cf2 2 
\fs24 \cf3 Note that room for the NUL should be included in dstsize.\cf0 \
\
\

\fs72 \cf2 3 
\fs24 \cf0 strlcat() appends string src to the end of dst. \

\fs72 \cf2 4
\fs24 \cf0  It will append at most 
\fs72 \cf4 dstsize - strlen(dst) - 1
\fs24 \cf0  characters.  \

\fs72 \cf2 5 
\fs24 \cf0 It will then NUL-terminate, unless dstsize is 0 or the original dst string was longer than dstsize (in practice this should not happen as it means that either dstsize is incorrect or that dst is not a proper string).\
\
If the src and dst strings overlap, the behavior is undefined.\
\

\f1\b RETURN VALUES
\f0\b0 \
Besides quibbles over the return type (size_t versus int) and signal handler safety (snprintf(3) is not entirely safe on some systems), the following two are equivalent:\
\
           n = strlcpy(dst, src, len);\
           n = snprintf(dst, len, "%s", src);\
\
Like snprintf(3), the strlcpy() and strlcat()
\fs72  
\fs24 functions return the total length of the string they tried to create.  \
\

\fs72 \cf2 6
\fs24 \cf0  For strlcat() that means the initial length of dst plus the length of src.\
\
If the return value is >= dstsize, the output string has been truncated.  \
It is the caller's responsibility to handle this.\
\

\f1\b EXAMPLES
\f0\b0 \
The following code fragment illustrates the simple case:\
\
           char *s, *p, buf[BUFSIZ];\
\
           ...\
\
           (void)strlcpy(buf, s, sizeof(buf));\
           (void)strlcat(buf, p, sizeof(buf));\
\
To detect truncation, perhaps while building a pathname, something like the following might be used:\
\
           char *dir, *file, pname[MAXPATHLEN];\
\
           ...\
\
           if (strlcpy(pname, dir, sizeof(pname)) >= sizeof(pname))\
                   goto toolong;\
           if (strlcat(pname, file, sizeof(pname)) >= sizeof(pname))\
                   goto toolong;\
\
Since it is known how many characters were copied the first time, things can be sped up a bit by using a copy instead of an append:\
\
           char *dir, *file, pname[MAXPATHLEN];\
           size_t n;\
\
           ...\
\
           n = strlcpy(pname, dir, sizeof(pname));\
           if (n >= sizeof(pname))\
                   goto toolong;\
           if (strlcpy(pname + n, file, sizeof(pname) - n) >= sizeof(pname) - n)\
                   goto toolong;\
\
However, one may question the validity of such optimizations, as they defeat the whole purpose of strlcpy() and strlcat(). \
As a matter of fact, the first version of this manual page got it wrong.\
\

\f1\b SEE ALSO
\f0\b0 \
     snprintf(3), strncat(3), strncpy(3), wcslcpy(3)\
\
}